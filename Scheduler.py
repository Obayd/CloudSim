from SimPy.Simulation import *
from AbstractResource import *
from CloudMachine import *

class Scheduler(Process):
    def __init__(self, scenario, name="Scheduler"):
        Process.__init__ (self, name=name)
        self.scenario = scenario

        self.started = False

        self.genId = 0
        self.activeMachines = []
        self.destroyedMachines = []

        self.jobsPerMachine = {}

        # [0] startTime
        # [1] remainingJobs
        self.taskInfos = {}
        self.taskJobs = {}

        self.tasksRT = []
        self.jobsRT = []

        temp = scenario.addMonitor ("activeNodesMon")
        scenario.addMonitorPlot ("Running nodes", temp)

        temp = scenario.addMonitor ("activeJobsMon")
        scenario.addMonitorPlot ("Running Jobs", temp)

        temp = scenario.addMonitor("jobRTAvgMon")
        scenario.addMonitorPlot ("Average job response time", temp)

        temp = scenario.addMonitor("taskRTAvgMon")
        scenario.addMonitorPlot ("Average task response time", temp)

        temp = scenario.addMonitor("executionCostMon")
        scenario.addMonitorPlot ("Cost of execution", temp)

        self.taskMeanTimes = {} #TaskId > meanCompletionTime

        self.jobTimes = {} #JobId > jobCompletionTime

        self.taskIncomingRate = {} #TaskId >

        self.nextPoll = 0


    def addJob(self, job):
        job.startTime = now()
 
        try:
          incomingRate = self.taskIncomingRate[job.taskId]
          if(incomingRate[1] == now()):
            incomingRate[0] += 1
            self.taskIncomingRate[job.taskId] = incomingRate
        except:
          self.taskIncomingRate[job.taskId] = [1, now()]
      
        self.jobTimes[(job.taskId, job.jobId)] = -now()

        jobList = self.taskJobs.get(job.taskId)
        if(jobList == None):
            jobList = []
            taskInfo = [job.startTime, job.numjobs]
            self.taskInfos[job.taskId] = taskInfo
        
        jobList.append(job)
        self.taskJobs[job.taskId] = jobList

    def jobFinished(self, job, machineId):
        finishTime = now()

        self.jobTimes[(job.taskId, job.jobId)] += finishTime

        jobTime = self.jobTimes[(job.taskId, job.jobId)]
        try:
          previousMean = self.taskMeanTimes[job.taskId]
          self.taskMeanTimes[job.taskId] = \
                  [(previousMean[0]*previousMean[1] + jobTime)/(previousMean[1]+1), previousMean[1]+1]
#print "Task mean of task %d was updated to %f" %(job.taskId, self.taskMeanTimes[job.taskId][0])

        except:
          self.taskMeanTimes[job.taskId] = [jobTime, 1]

        # Remove job from job list
        self.taskJobs[job.taskId].remove(job)
        jobsInMachine = self.jobsPerMachine.get(machineId)
        jobsInMachine.remove(job)
        self.jobsPerMachine[machineId] = jobsInMachine
        
        # Calculate job service time
        jobRT = finishTime - job.startTime
        self.jobsRT.append(jobRT)


        # Complete job in task info and check if
        # task is completed
        taskInfo = self.taskInfos[job.taskId]
        taskInfo[1] -= 1
       
#print "Remaining jobs from task %d: %d" %(job.taskId, taskInfo[1])

        # No jobs remaining - Task finished!
        if(taskInfo[1] == 0):
            print "Task %d is finished" %(job.taskId)
            # Calculate task service time
            taskRT = finishTime - taskInfo[0] #initialTime
            self.tasksRT.append(taskRT)
        
        allFinished = True
        for info in self.taskInfos.values():
            if(info[1] > 0):
                allFinished = False
                break

        if(allFinished and self.scenario.remainingTasks == 0):
            stopSimulation()
    def run(self):

        # Create initial machines
        for m_id in range(self.scenario.initial_machines):
           self.createMachine(1)

        self.started = True

        while (self.started):
            allocations = self.scenario.schedule_algorithm (self.activeMachines, self.taskJobs, self)

            # iterate over allocations generated by scheduling algorithm
            for machine_job in allocations:
                machine = machine_job[0]
                job = machine_job[1]

                if(machine == None and job == None):
                  # Invalid allocation
                  continue

                # if job is undefined, shutdown machine
                if(job == None):
                    self.destroyMachine(machine)
                else:
                    # if machine is undefined, start machine
                    if(machine == None):
                        machine = self.createMachine()

                    # start job on machine
                    machine.addJob(job)
 
                    jobsInMachine = self.jobsPerMachine.get(machine.id)
                    if(jobsInMachine == None):
                        jobsInMachine = []
                    jobsInMachine.append(job)
                    self.jobsPerMachine[machine.id] = jobsInMachine
           

            if(int(now()) == self.nextPoll):
                self.scenario.monitors ["activeJobsMon"].observe (sum(map(lambda x: len(x), self.taskJobs.values())))
                self.scenario.monitors ["activeNodesMon"].observe (len(self.activeMachines))

                if(len(self.jobsRT) > 0):
                    self.scenario.monitors ["jobRTAvgMon"].observe (sum(self.jobsRT)/len(self.jobsRT))
                if(len(self.tasksRT) > 0):
                    self.scenario.monitors ["taskRTAvgMon"].observe (sum(self.tasksRT)/len(self.tasksRT))

                currentCost = 0.0
                for machine in self.activeMachines+self.destroyedMachines:
                    currentCost += machine.getExecutionCost()
                self.scenario.monitors ["executionCostMon"].observe (currentCost)

                self.nextPoll += self.scenario.pollingInterval

            yield hold, self, self.scenario.sch_interval
       
    def guessEstimatedTime(self, taskId):
        remainingJobs = self.taskInfos[taskId][1]

        remainingJobs -= len(self.taskJobs[taskId])

        return remainingJobs    

 
    def destroyMachine(self, machine):
        machine.stop()
        cancel(machine)
        self.activeMachines.remove(machine)
        self.destroyedMachines.append(machine)

    def createMachine(self, started=0):
        machine = CloudMachine(self.genId, self.scenario, started)
        self.activeMachines.append(machine)
        self.genId += 1
        activate(machine, machine.start())
        return machine


    def stop(self):
        self.started = False

